import Geocode from "react-geocode";
import { auth, firestore } from 'firebase';
const { detect } = require('detect-browser');
import AsyncStorage from '@react-native-community/async-storage';
import { REACT_APP_API_URL, REACT_APP_GEOCODE_API_KEY } from "react-native-expand-dotenv";

import * as Types from './types'
import * as Options from '../components/utils/Options';
import {
    handleError,
    calculateDistanceFromLatLonInKm,
    calculateAge,
    decodeJwtToken,
    convertDateFormatToHHMM
} from '../components/utils/Functions';
import Api from '../components/utils/Api';

/*
ActionCreators -> create/return Actions ({ }) -> dispatched -> middlewares -> reducers
*/
Geocode.setLanguage("pt");
Geocode.setRegion("br");
Geocode.setApiKey(REACT_APP_GEOCODE_API_KEY);

const unsubscribeFirebaseListeners = [];

const helper = {
    accessToken: AsyncStorage.getItem('accessToken'),
    userData: { id: AsyncStorage.getItem('accessToken').then((value) => decodeJwtToken(value).id) },
    alreadyDownloadedProfileIds: [],
    currentLongitude: 0,
    currentLatitude: 0,
    firebaseUid: '',
    currentRoute: '/'
};

const setAccessTokenOnStorageAndUpdateHelper = (token) => {

    AsyncStorage.setItem('accessToken', token || '');
    helper.accessToken = token || [];

    //also needs to update userData.id cause it's going to be used to get data from resource server
    helper.userData.id = decodeJwtToken(token).id;
}

export function updateHelperRoute(newHelperRoute) {
    return () => {
        helper.currentRoute = newHelperRoute;
    }
}

export function checkIfTokenHasExpired() {
    return async dispatch => {
        try {
            console.log('asd')
            console.log(REACT_APP_API_URL)
            await Api({ accessToken: helper.accessToken }).post('account/check_if_token_has_expired', { /*body*/ });
            console.log('qwe')
            dispatch({
                type: Types.CHECK_IF_TOKEN_HAS_EXPIRED,
                isAuthenticated: true
            });

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function signInOrSignUpToFirebase() {//try sign in, if there's no record, sign up then
    return async dispatch => {

        const db = firestore();

        const createUserOnFirebase = async (user) => {
            try {
                await db.collection('users')
                    .doc(user.uid)
                    .set({
                        mySqlUserId: helper.userData.id,
                        uid: user.uid,//generated by firebase
                        isOnline: true,
                        createdAt: new Date()
                    });

                helper.firebaseUid = user.uid;
                dispatch(getRealTimeUsersFromFirebase(user.uid));
            } catch (error) {

                handleError(error);
            };
        }

        auth().signInWithEmailAndPassword(helper.userData.email, helper.userData.email).then(user => {

            helper.firebaseUid = user.user.uid;
            dispatch(updateFirebaseUser({ isOnline: true }));
            dispatch(getRealTimeUsersFromFirebase(user.user.uid));
            dispatch(getRealtimeMessagesFromFirebase());

            dispatch({
                type: Types.UPDATE_FIREBASE_USER,
                firebaseUser: { uid: user.user.uid }
            });

        }).catch(error => {

            if (error.code === 'auth/user-not-found') {

                auth().createUserWithEmailAndPassword(helper.userData.email, helper.userData.email).then(user => {

                    createUserOnFirebase({ uid: user.user.uid });

                    dispatch({
                        type: Types.UPDATE_FIREBASE_USER,
                        firebaseUser: { uid: user.user.uid }
                    });

                }).catch(error => {
                    handleError(error);

                })
            }
            else {
                handleError(error);
            }
        })
    }
}

export function getRealTimeUsersFromFirebase() {
    return dispatch => {
        //atm I'm not using this method, will be usfull soon when I create the online/offline function at the chat
        const db = firestore();
        var users = [];

        unsubscribeFirebaseListeners.push(db.collection("users")
            .onSnapshot(function (querySnapshot) {

                users = [];
                querySnapshot.forEach(function (doc) {
                    users.push(doc.data());
                });
            }));

        dispatch({
            type: Types.UPDATE_REAL_TIME_FIREBASE_USERS,
            realTimeFirebaseUsers: users
        });
    }
}

export function getRealtimeMessagesFromFirebase() {
    return dispatch => {

        const db = firestore();
        var realTimeFirebaseChat1 = [];
        var realTimeFirebaseChat2 = [];
        var realTimeFirebaseChatFinal = [];
        //I'm using this two helper arrays cause firestore doesn't accept OR operator

        unsubscribeFirebaseListeners.push(
            db.collection('chat')
                .where('userId_1', '==', helper.userData.id)
                .orderBy('createdAt', 'asc')
                .onSnapshot(async (querySnapshot) => {

                    realTimeFirebaseChat1 = [];
                    querySnapshot.forEach(doc => {
                        realTimeFirebaseChat1.push(doc.data());
                    });

                    unsubscribeFirebaseListeners.push(db.collection('chat')
                        .where('userId_2', '==', helper.userData.id)
                        .orderBy('createdAt', 'asc')
                        .onSnapshot(async (querySnapshot) => {

                            realTimeFirebaseChat2 = [];
                            querySnapshot.forEach(doc => {
                                realTimeFirebaseChat2.push(doc.data());
                            });

                            realTimeFirebaseChatFinal = [];

                            realTimeFirebaseChatFinal = realTimeFirebaseChat1.concat(realTimeFirebaseChat2)
                                .sort((a, b) => b.createdAt - a.createdAt)//order all messages desc by date

                            realTimeFirebaseChatFinal = realTimeFirebaseChatFinal.map(item => ({
                                ...item,
                                hourMinute: convertDateFormatToHHMM(item.createdAt.toDate())
                            }));

                            dispatch({
                                type: Types.UPDATE_REAL_TIME_FIREBASE_CHAT,
                                realTimeFirebaseChat: realTimeFirebaseChatFinal
                            });
                        })
                    );
                })
        );
    }
}

export function sendMessageToFirebase(message, profileId) {
    return async dispatch => {

        const db = firestore();
        await db.collection('chat')
            .add({
                userId_1: helper.userData.id,
                userId_2: profileId,
                createdAt: new Date(),
                isView: false,
                message
            })
            .catch(error => {
                handleError(error);
            });
    }
}

export function updateFirebaseUser(user) {
    return async dispatch => {

        const db = firestore();

        await db.collection('users')
            .doc(helper.firebaseUid && helper.firebaseUid)
            .update(user);
    }
}

export function signOut() {
    return async dispatch => {

        helper.firebaseUid && dispatch(updateFirebaseUser({ isOnline: false }));

        unsubscribeFirebaseListeners.map(item => item());

        auth().signOut();//firebase sign out

        dispatch(openCompleteYourProfileModal(false));
        dispatch(showGenericYesNoModal(false))
        dispatch(showSignUpModal(false));
        dispatch(showLeftProfile(false));

        dispatch(cleanMatchSearcherArrayAndGetNextProfile(false));
        dispatch(updateMatchProfileArray([]));

        setAccessTokenOnStorageAndUpdateHelper(null);

        dispatch({ type: Types.AUTH_SIGN_OUT });

        /* the page is being refreshed here so when the user try login again on facebook it will not
        redirect it to a facebook error page:
        Also as location.reload() fires in a loop, I needed to add this verification, so it will fire only once*/
        if (helper.currentRoute == '/dashboard')
            window.location.reload();
    }
}

export function getAddress(shouldGetMatchProfilesForMatchSearcher, shouldGetMatchProfiles) {
    return dispatch => {

        const geolocationError = () => {

            dispatch(showTurnOnLocationModal(true));

            dispatch({
                type: Types.IS_GEOLOCATION_ENABLE,
                isGeolocationEnabled: false
            })

            dispatch({
                type: Types.UPDATE_ADDRESS,
                address: 'Ative a geolocalização do seu navegador'
            })
        }

        if ("geolocation" in navigator) {

            navigator.geolocation.getCurrentPosition((position) => {

                Geocode.fromLatLng(position.coords.latitude, position.coords.longitude).then(
                    response => {

                        let address = response.results[0].formatted_address.split(',');

                        const browser = detect();

                        let cityState;
                        let country;

                        switch (browser.name) {
                            case 'chrome':
                                cityState = address[2];
                                country = address[4];
                                break;
                            default:
                                cityState = address[1];
                                country = address[2];
                                break;
                        }

                        address = `${cityState && cityState}, ${country && country}`;

                        dispatch({
                            type: Types.IS_GEOLOCATION_ENABLE,
                            isGeolocationEnabled: true
                        })

                        dispatch({
                            type: Types.UPDATE_ADDRESS,
                            address
                        })

                        dispatch(updateUser({
                            lastLongitude: position.coords.longitude,
                            lastLatitude: position.coords.latitude
                        }));

                        helper.currentLongitude = position.coords.longitude;
                        helper.currentLatitude = position.coords.latitude;

                        //this 2 methods are here cause I need call it after get geolocation
                        shouldGetMatchProfilesForMatchSearcher &&
                            dispatch(getNextProfileForTheMatchSearcher());

                        shouldGetMatchProfiles &&
                            dispatch(getMatchProfiles());
                    },
                    error => {
                        console.error(error);
                        handleError(error);
                    }
                );
            }, (error) => {
                console.error(error);
                handleError(error);
                geolocationError();
            });
        } else {
            geolocationError();
        }
    }
}

export function getMatchProfiles() {
    return async dispatch => {//get only profiles that was already matched with current user

        try {
            const res = await Api({ accessToken: helper.accessToken }).get(`users/get_match_profiles/${helper.userData.id}`, {});

            res.data.map(item => {
                item.age = calculateAge(new Date(item.birthday))
                item.distance = parseInt(calculateDistanceFromLatLonInKm(
                    helper.currentLongitude,
                    helper.currentLatitude,
                    item.lastLongitude,
                    item.lastLatitude
                ))
            });

            dispatch(updateMatchProfileArray(res.data));

        } catch (err) {
            dispatch(handleActionError(err));
        }
    }
}

export function updateMatchProfileArray(matchProfiles) {
    return {
        type: Types.UPDATE_MATCH_PROFILE_ARRAY,
        matchProfiles
    }
}

export function isSearchingProfileStatus(isSearchingProfiles) {
    return {
        type: Types.IS_SEARCHING_PROFILES,
        isSearchingProfiles
    }
}

export function getNextProfileForTheMatchSearcher() {
    return async dispatch => {
        try {
            dispatch(isSearchingProfileStatus(true));

            const res = await Api({ accessToken: helper.accessToken }).post(`users/get_profile_to_the_match_searcher`, {
                currentLongitude: helper.currentLongitude,
                currentLatitude: helper.currentLatitude,
                maxDistance: helper.userData.maxDistance,
                userId: helper.userData.id,
                searchingBy: helper.userData.searchingBy.key,
                alreadyDownloadedProfileIds: helper.alreadyDownloadedProfileIds,
                ageRange: helper.userData.ageRange
            });

            if (res.data.user) {
                res.data.user.distance = parseInt(calculateDistanceFromLatLonInKm(
                    helper.currentLongitude,
                    helper.currentLatitude,
                    res.data.user.lastLongitude,
                    res.data.user.lastLatitude
                ));

                res.data.user.age = calculateAge(new Date(res.data.user.birthday));

                dispatch(addUserIntoMatchSearcherArray(res.data.user));

                helper.alreadyDownloadedProfileIds.push(res.data.user.id);

                /*matchSearcherProfiles must have at least 2 profiles, so when user likes/ignores the first one,
                the second will appear*/
                helper.alreadyDownloadedProfileIds.length === 1 ?
                    dispatch(getNextProfileForTheMatchSearcher())
                    :
                    dispatch(isSearchingProfileStatus(false));
            }
            else
                dispatch(isSearchingProfileStatus(false));

        } catch (err) {

            dispatch(isSearchingProfileStatus(false));
            dispatch(showLoader(false));
            dispatch(handleActionError(err));
        }
    }
}

export function addUserIntoMatchSearcherArray(user) {
    return {
        type: Types.ADD_USER_TO_THE_MATCH_SEARCHER_ARRAY,
        user
    };
}

export function updateUser(user, shouldShowLoader, closeLeftProfileEditor, shouldCleanMatchSearcherArray) {
    return async dispatch => {
        try {

            if (shouldShowLoader)
                dispatch(showLoader(true));

            user.id = helper.userData.id;
            await Api({ accessToken: helper.accessToken }).post(`users/update_user`, { user });

            await dispatch(getUserData());
            dispatch(showLoader(false));

            closeLeftProfileEditor && dispatch(showLeftProfileEditor(false));
            shouldCleanMatchSearcherArray && dispatch(cleanMatchSearcherArrayAndGetNextProfile(true));

        } catch (err) {

            dispatch(showLoader(false));
            dispatch(handleActionError(err));
        }
    }
}

export function cleanMatchSearcherArrayAndGetNextProfile(shouldGetNextProfileForTheMatchSearcher) {
    return dispatch => {
        helper.alreadyDownloadedProfileIds = [];
        dispatch(removeUserFromMatchSearcher(null, true));

        shouldGetNextProfileForTheMatchSearcher &&
            dispatch(getNextProfileForTheMatchSearcher());
    }
}

export function ignoreCurrentProfile(profile) {
    return dispatch => {
        dispatch(removeUserFromMatchSearcher(profile.id));
        dispatch(getNextProfileForTheMatchSearcher());
    }
}

export function likeCurrentProfile(profile, superLike) {
    return dispatch => {
        dispatch(createOrUpdateUserMatch(profile, superLike));
        dispatch(removeUserFromMatchSearcher(profile.id));
        dispatch(getNextProfileForTheMatchSearcher());
    }
}

export function createOrUpdateUserMatch(profile, superLike) {
    return async dispatch => {
        try {

            const res = await Api({ accessToken: helper.accessToken }).post('users/create_or_update_user_match', {
                userId: helper.userData.id,
                profileId: profile.id,
                superLike
            });

            if (res.data === 'you have a match!') {

                dispatch(setSelectedMatchProfileData(profile));//will be used on "YouHaveAMatchModal"
                dispatch(getMatchProfiles());
                dispatch(openYouHaveAMatchModal(true));
            }

        } catch (err) {
            dispatch(handleActionError(err));
        }
    }
}

export function openYouHaveAMatchModal(open) {
    return {
        type: Types.OPEN_YOU_HAVE_A_MATCH_MODAL,
        isYouHaveAMatchModalOpen: open,
    }
}

export function removeUserFromMatchSearcher(userId, removeAll) {
    return ({
        type: Types.REMOVE_USER_FROM_THE_MATCH_SEARCHER_ARRAY,
        userId,
        removeAll
    });
}

export function getUserData(
    shouldGetAddress,
    shouldGetMatchProfilesForMatchSearcher,
    shouldSignInOnFirebase,
    shouldGetMatchProfiles
) {
    const populateSearchingByDesc = (userData) => {
        const searchingByOptions = Options.searchingByOptions();

        let index = 0;
        for (let i = 0; i <= searchingByOptions.length - 1; i++) {
            if (userData.searchingBy === searchingByOptions[i].key)
                index = i;
        }

        return userData.searchingByDesc = searchingByOptions[index].label;
    }

    const populateSchoolingDesc = (userData) => {
        const schoolingOptions = Options.schoolingOptions();

        let index = 0;
        for (let i = 0; i <= schoolingOptions.length - 1; i++) {
            if (userData.schooling === schoolingOptions[i].key)
                index = i;
        }

        return userData.schoolingDesc = schoolingOptions[index].label;
    }

    const populateGenderDesc = (userData) => {
        const genderOptions = Options.genderOptions();

        let index = 0;
        for (let i = 0; i <= genderOptions.length - 1; i++) {
            if (userData.gender === genderOptions[i].key)
                index = i;
        }

        return userData.genderDesc = genderOptions[index].label;
    }

    return async dispatch => {
        try {
            const res = await Api({ accessToken: helper.accessToken }).get(`users/get_user/${helper.userData.id}`, {});

            const userData = res.data;
            helper.userData = userData;

            //doing the following verification because getAddress() gets match profile too... so it won't get it twice
            if (shouldGetAddress)
                dispatch(getAddress(shouldGetMatchProfilesForMatchSearcher, shouldGetMatchProfiles));
            else {
                shouldGetMatchProfilesForMatchSearcher && dispatch(getNextProfileForTheMatchSearcher());
                shouldGetMatchProfiles && dispatch(getMatchProfiles());
            }

            shouldSignInOnFirebase && dispatch(signInOrSignUpToFirebase());

            populateSearchingByDesc(userData);
            populateSchoolingDesc(userData);
            populateGenderDesc(userData);

            //treatment on userData fields to be correctly "read" by the app
            const ageRange = userData.ageRange.split(',');
            userData.ageRange = ageRange;
            userData.schooling = { key: userData.schooling, label: userData.schoolingDesc };
            userData.gender = { key: userData.gender, label: userData.genderDesc };
            userData.searchingBy = { key: userData.searchingBy, label: userData.searchingByDesc };
            userData.birthday = new Date(userData.birthday);//necessary to work properly on datePicker
            userData.age = calculateAge(userData.birthday);

            userData.UserImages.map(item => {
                item.progress = 0;
                item.uploaded = true;
                item.error = false;
            });

            dispatch(updateUserDataOnRedux(userData));
            dispatch(openCompleteYourProfileModal(!userData.profileComplete && true));

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function showProfileCardEditMode(isProfileCardEditModeOpen) {
    return {
        type: Types.PROFILE_CARD_EDIT_MODE,
        isProfileCardEditModeOpen
    };
}

export function isMouseButtonDown(isMouseButtonDown) {
    return {
        type: Types.MOUSE_BUTTON_DOWN,
        isMouseButtonDown
    };
}

export function updateUploadingImagesPreview(image, removeImageByThisId) {
    return {
        type: Types.UPLOADING_IMAGES,
        image,
        removeImageByThisId
    };
}

export function updateSelectedLeftProfileEditor(selectedLeftProfileEditor) {
    return dispatch => {

        dispatch({
            type: Types.UPDATE_SELECTED_LEFT_PROFILE_EDITOR,
            selectedLeftProfileEditor
        });

        dispatch(showLeftProfileEditor(true));
    }
}

export function showLeftProfileEditor(isLeftProfileEditorOpen) {
    return ({
        type: Types.SHOW_LEFT_PROFILE_EDITOR,
        isLeftProfileEditorOpen
    });
}

export function showLeftProfile(isLeftProfileOpen) {
    return ({
        type: Types.SHOW_LEFT_PROFILE,
        isLeftProfileOpen
    });
}

export function openCompleteYourProfileModal(isCompleteYourProfileModalOpen) {
    return {
        type: Types.OPEN_COMPLETE_YOUR_PROFILE_MODAL,
        isCompleteYourProfileModalOpen: isCompleteYourProfileModalOpen
    }
}

export function setSelectedMatchProfileDataAndOpenChatPanel(selectedMatchProfileData, isChatPanelOpen) {
    return dispatch => {
        dispatch(setSelectedMatchProfileData(selectedMatchProfileData));
        dispatch(openChatPanel(isChatPanelOpen));
    }
}

export function setSelectedMatchProfileData(selectedMatchProfileData) {
    return {
        type: Types.SET_SELECTED_MATCH_PROFILE_DATA,
        selectedMatchProfileData
    };
}

export function openChatPanel(isChatPanelOpen) {
    return {
        type: Types.OPEN_CHAT_PANEL,
        isChatPanelOpen
    }
}

export function openMobileConfig(isMobileConfigOpen) {
    return {
        type: Types.OPEN_MOBILE_CONFIG,
        isMobileConfigOpen
    }
}

export function openMobileEditInfo(isMobileEditInfoOpen) {
    return {
        type: Types.OPEN_MOBILE_EDIT_INFO,
        isMobileEditInfoOpen
    }
}

export function updateUserDataOnRedux(userData) {
    return {
        type: Types.UPDATE_USER_DATA_ON_REDUX,
        userData: userData
    }
}

export function signUpAction(userData) {
    return async dispatch => {
        try {

            dispatch(showLoader(true));

            const res = await Api({ accessToken: helper.accessToken }).post('account/signup', userData);

            setAccessTokenOnStorageAndUpdateHelper(res.data.token);

            dispatch({
                type: Types.AUTH_SIGN_UP,
            });

            dispatch(showLoader(false));
            dispatch(showSignUpModal(false));

        } catch (err) {

            dispatch(showLoader(false));
            dispatch(handleActionError(err));
        }
    }
}

export function deleteUserImage(imageId) {
    return async dispatch => {
        try {

            await Api({ accessToken: helper.accessToken }).delete(`users/user_images/${imageId}`);

            dispatch(getUserData(true));
            dispatch(showGenericYesNoModal(false));

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function unmatch(profileId) {
    return async dispatch => {
        try {

            await Api({ accessToken: helper.accessToken }).post(`users/unmatch`,
                { userId: helper.userData.id, profileId }
            );

            await dispatch(removeAllConversationsFromThisMatch(profileId));
            dispatch(setSelectedMatchProfileDataAndOpenChatPanel(null, false));
            dispatch(getUserData(true, true, false, true));
            dispatch(showGenericYesNoModal(false));

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function removeAllConversationsFromThisMatch(profileId) {
    return dispatch => {
        try {

            const db = firestore();

            const conversation1 = db.collection('chat')
                .where('userId_1', '==', helper.userData.id)
                .where('userId_2', '==', profileId);

            conversation1.get().then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            });

            const conversation2 = db.collection('chat')
                .where('userId_1', '==', profileId)
                .where('userId_2', '==', helper.userData.id);

            conversation2.get().then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            });

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function deleteAccount() {
    return async dispatch => {
        try {

            await Api({ accessToken: helper.accessToken }).delete(
                `account/delete-account/${helper.userData.id}`
            ).then(() =>
                dispatch(signOut())
            );

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function signInLocalAction(userData) {
    return async dispatch => {
        try {

            dispatch(showLoader(true));

            const res = await Api({ accessToken: helper.accessToken }).post('account/signin', userData);

            setAccessTokenOnStorageAndUpdateHelper(res.data.token);

            dispatch(showLoader(false));

            dispatch({ type: Types.AUTH_SIGN_IN });

        } catch (err) {

            dispatch(handleActionError(err));
        }
    }
}

export function handleActionError(err) {
    return dispatch => {

        dispatch(showLoader(false));

        //status 401 is Unauthorized, wich means that the token expired
        if (err.response && err.response.status == 401 && err.response.data == 'Unauthorized')
            dispatch(signOut());
        else
            handleError(err);
    }
}

export function signInOauthAction(oauthAccessToken, type) {
    return async dispatch => {
        try {

            dispatch(showLoader(true));

            let res;

            switch (type) {
                case 'facebook':
                    res = await Api({ accessToken: helper.accessToken }).post('account/facebook', { access_token: oauthAccessToken });
                    break;
                default:
                    res = await Api({ accessToken: helper.accessToken }).post('account/google', { access_token: oauthAccessToken });
                    break;
            }

            setAccessTokenOnStorageAndUpdateHelper(res.data.token);

            dispatch(showLoader(false));

            dispatch({ type: Types.AUTH_SIGN_IN });

        } catch (err) {
            dispatch(handleActionError(err));
        }
    }
}

export function showTurnOnLocationModal(show) {
    return ({
        type: Types.OPEN_TURN_ON_LOCATION_MODAL,
        isTurnOnLocationModalOpen: show
    })
}

export function showContactModal(show) {
    return ({
        type: Types.OPEN_CONTACT_MODAL,
        isContactModalOpen: show
    })
}

export function showGenericYesNoModal(show, title, subtitle, acceptText, denyText, selectedMethod) {

    AsyncStorage.setItem('genericYesNoModalTitle', title);
    AsyncStorage.setItem('genericYesNoModalSubtitle', subtitle);
    AsyncStorage.setItem('genericYesNoModalAcceptText', acceptText);
    AsyncStorage.setItem('genericYesNoModalDenyText', denyText);
    AsyncStorage.setItem('genericYesNoModalSelectedMethod', selectedMethod);

    return ({
        type: Types.OPEN_GENERIC_YES_NO_MODAL,
        isGenericYesNoModalOpen: show
    })
}

export function showForgotPasswordModal(show) {
    return ({
        type: Types.OPEN_FORGOT_PASSWORD_MODAL,
        isForgotPasswordModalOpen: show
    })
}

export function showSignUpModal(show) {
    return ({
        type: Types.OPEN_SIGN_UP_MODAL,
        isSignUpModalOpen: show
    })
}

export function showLoader(show) {
    return ({
        type: Types.SHOW_LOADER,
        showLoader: show
    })
}
